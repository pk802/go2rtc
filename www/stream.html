<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" href="https://alexxit.github.io/go2rtc/icons/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="icon" href="https://alexxit.github.io/go2rtc/icons/favicon.ico">
    <link rel="manifest" href="https://alexxit.github.io/go2rtc/manifest.json">
    <title>go2rtc - Stream</title>
    <style>
        body {
            background: black;
            margin: 0;
            padding: 0;
            display: flex;
            font-family: Arial, Helvetica, sans-serif;
            flex-direction: column;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        .flex {
            flex-wrap: wrap;
            align-content: flex-start;
            align-items: flex-start;
            flex: 1;
        }
        
        .controls-panel {
            background: #333;
            color: white;
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            min-height: 40px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            min-width: 70px;
        }
        
        .pause-btn { background: #ffc107; color: black; }
        .resume-btn { background: #28a745; color: white; }
        .quality-btn { background: #6c757d; color: white; }
        
        .status-text {
            color: #ccc;
            font-size: 12px;
            font-family: monospace;
        }
        
        .bandwidth-monitor {
            color: #8bc34a;
            font-size: 11px;
        }
        
        .video-container {
            flex: 1;
            display: flex;
        }
    </style>
</head>
<body>
<!-- Pause/Resume Controls Panel -->
<div class="controls-panel">
    <div class="control-group">
        <label>Stream Controls:</label>
        <button class="control-btn pause-btn" onclick="pauseStream()">‚è∏Ô∏è PAUSE</button>
        <button class="control-btn resume-btn" onclick="resumeStream()">‚ñ∂Ô∏è RESUME</button>
    </div>

    <div class="control-group">
        <span class="status-text" id="status">Ready</span>
        <span class="bandwidth-monitor" id="bandwidth">Monitor bandwidth in DevTools</span>
    </div>
</div>

<!-- Video Container -->
<div class="video-container" id="videoContainer">
</div>

<script type="module" src="./video-stream.js"></script>
<script type="module">
    const params = new URLSearchParams(location.search);

    // support multiple streams and multiple modes
    const streams = params.getAll('src');
    const modes = params.getAll('mode');
    if (modes.length === 0) modes.push('');

    while (modes.length > streams.length) {
        streams.push(streams[0]);
    }
    while (streams.length > modes.length) {
        modes.push(modes[0]);
    }

    const videoContainer = document.getElementById('videoContainer');
    
    if (streams.length > 1) {
        videoContainer.className = 'flex';
    }

    const background = params.get('background') !== 'false';
    const width = '1 0 ' + (params.get('width') || '320px');

    // Store video streams for control access
    window.videoStreams = [];
    window.activeConnections = [];

    // Generate unique viewer ID for this browser tab/session
    if (!window.viewerID) {
        window.viewerID = 'viewer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        console.log('Generated viewer ID:', window.viewerID);
    }

    for (let i = 0; i < streams.length; i++) {
        /** @type {VideoStream} */
        const video = document.createElement('video-stream');
        video.background = background;
        video.mode = modes[i] || video.mode;
        video.style.flex = width;
        
        // Add viewer ID to the WebSocket URL for WebRTC connection tracking
        video.src = new URL('api/ws?src=' + encodeURIComponent(streams[i]) + '&viewer_id=' + encodeURIComponent(window.viewerID), location.href);
        
        // Store reference for controls
        window.videoStreams.push(video);
        
        videoContainer.appendChild(video);
        
        // Store video element reference for WebSocket access
        video.streamName = streams[i];
        
        // Override the onopen method to track connection
        const originalOnOpen = video.onopen.bind(video);
        video.onopen = function() {
            const result = originalOnOpen();
            updateStatus(`‚úÖ Connected to ${streams[i]} (Viewer: ${window.viewerID})`);
            return result;
        };
        
        // Listen for session ID from server
        video.addEventListener('sessionreceived', function(event) {
            window.serverSessionID = event.detail.sessionID;
            console.log('üéØ Server session ID captured:', window.serverSessionID);
            updateStatus(`‚úÖ Connected to ${streams[i]} (Session: ${window.serverSessionID.substring(0, 8)}...)`);
        });
    }

    // Control Functions using HTTP API (since WebSocket closes after WebRTC setup)
    window.pauseStream = function() {
        // Prefer server session ID over client viewer ID for better control
        if (window.serverSessionID) {
            console.log('üî• PAUSE BUTTON CLICKED - Using server session ID:', window.serverSessionID.substring(0, 8) + '...');
            
            fetch('/api/webrtc/session/pause', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    session_id: window.serverSessionID
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('‚úÖ Session pause response:', data);
                updateStatus('‚è∏Ô∏è PAUSED (Server-controlled session)');
            })
            .catch(error => {
                console.error('‚ùå Session pause error:', error);
                updateStatus('‚ùå Session pause failed');
            });
        } else {
            console.log('üî• PAUSE BUTTON CLICKED - Fallback to viewer ID:', window.viewerID);
            
            // Fallback to viewer ID method
            fetch('/api/webrtc/pause', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'pause',
                    viewer_id: window.viewerID
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('‚úÖ Pause response:', data);
                updateStatus('‚è∏Ô∏è PAUSED - This viewer only');
            })
            .catch(error => {
                console.error('‚ùå Pause error:', error);
                updateStatus('‚ùå Pause failed - ' + error.message);
            });
        }
    };

    window.resumeStream = function() {
        // Prefer server session ID over client viewer ID for better control
        if (window.serverSessionID) {
            console.log('üî• RESUME BUTTON CLICKED - Using server session ID:', window.serverSessionID.substring(0, 8) + '...');
            
            fetch('/api/webrtc/session/resume', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    session_id: window.serverSessionID
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('‚úÖ Session resume response:', data);
                updateStatus('‚ñ∂Ô∏è RESUMED (Server-controlled session)');
            })
            .catch(error => {
                console.error('‚ùå Session resume error:', error);
                updateStatus('‚ùå Session resume failed');
            });
        } else {
            console.log('üî• RESUME BUTTON CLICKED - Fallback to viewer ID:', window.viewerID);
            
            // Fallback to viewer ID method
            fetch('/api/webrtc/resume', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'resume',
                    viewer_id: window.viewerID
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('‚úÖ Resume response:', data);
                updateStatus('‚ñ∂Ô∏è RESUMED - This viewer only');
            })
            .catch(error => {
                console.error('‚ùå Resume error:', error);
                updateStatus('‚ùå Resume failed - ' + error.message);
            });
        }
    };



    function updateStatus(message) {
        const status = document.getElementById('status');
        const timestamp = new Date().toLocaleTimeString();
        status.textContent = `[${timestamp}] ${message}`;
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) return;
        
        switch(e.key.toLowerCase()) {
            case 'p': pauseStream(); break;
            case 'r': resumeStream(); break;
        }
    });

    updateStatus('Ready - Keyboard: (p)ause, (r)esume');
        
        // Debug function to check connections
        window.debugConnections = function() {
            console.log('üîç Current viewer ID:', window.viewerID);
            console.log('üîç Current session ID:', window.serverSessionID);
            console.log('Video streams:', window.videoStreams.length);
            window.videoStreams.forEach((video, i) => {
                console.log(`Stream ${i}:`, {
                    streamName: video.streamName,
                    sessionID: video.sessionID,
                    hasWS: !!video.ws,
                    wsState: video.ws ? video.ws.readyState : 'null',
                    wsStateText: video.ws ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][video.ws.readyState] : 'null'
                });
            });
            
            // Fetch active sessions from server
            fetch('/api/webrtc/sessions')
            .then(response => response.json())
            .then(data => {
                console.log('üîç Active sessions from server:', data);
            })
            .catch(error => {
                console.error('‚ùå Failed to fetch sessions:', error);
            });
        };
        
        // Auto-check connections every 5 seconds
        setInterval(() => {
            const activeCount = window.videoStreams.filter(video => 
                video.ws && video.ws.readyState === WebSocket.OPEN
            ).length;
            if (activeCount === 0) {
                updateStatus('‚ö†Ô∏è No active WebSocket connections');
            }
        }, 5000);
</script>
</body>
</html>
